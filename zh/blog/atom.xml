<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://devlake.apache.org/zh/blog</id>
    <title>Apache DevLake (Incubating) Blog</title>
    <updated>2022-05-20T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://devlake.apache.org/zh/blog"/>
    <subtitle>Apache DevLake (Incubating) Blog</subtitle>
    <icon>https://devlake.apache.org/zh/img/logo.svg</icon>
    <entry>
        <title type="html"><![CDATA[如何贡献issue]]></title>
        <id>/2022/05/20/如何贡献issues</id>
        <link href="https://devlake.apache.org/zh/blog/2022/05/20/如何贡献issues"/>
        <updated>2022-05-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[上周(2022-05-12)，我们以先到先得的方式为大家列出了两个"good first issue"。]]></summary>
        <content type="html"><![CDATA[<p>上周(2022-05-12)，我们以先到先得的方式为大家列出了两个"good first issue"。
这很有趣，它们几乎立刻就被拿走了......
但对于那些有兴趣但没有得到的人来说可能就不那么有趣了。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="所以">所以...<a class="hash-link" href="#所以" title="标题的直接链接">​</a></h3><p>我们决定，不再有竞争，你可以从我们的github issue pages中挑选你喜欢的issue。如果没有了，甚至可以创建你自己的。
我们毕竟是社区！</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="怎么做呢这很简单">怎么做呢？这很简单!<a class="hash-link" href="#怎么做呢这很简单" title="标题的直接链接">​</a></h3><p>进入我们的<a href="https://github.com/apache/incubator-devlake/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22" target="_blank" rel="noopener noreferrer">问题页面</a>，然后点击这里。我们所有的Good First Issue都列在这里!
<img loading="lazy" alt="good first issue" src="/zh/assets/images/issue_page_screenshot-4aa3f48811d5bc6aa1a36ce71727344c.png" width="1320" height="266" class="img_E7b_"></p><ul><li><p>首先，寻找现有的issues，找到一个你喜欢的。
你可以通过评论"I'll take it!"来预订它。
接下来你可以写一份“攻略”，以展示你对问题的理解和你将采取什么样的步骤来解决这个issue，然后开始Coding。</p></li><li><p>如果没有GFI了怎么办？创造你自己的issue! 现在，通过查看我们的代码库。
你肯定能发现很多问题，比如文档、单元测试，甚至是错字。
把你觉得不对的地方提出来，我们会验证它是否必要，
然后你就可以开始Coding了。</p></li><li><p>最后，你可能会问，我为什么要费尽心思为你写代码？
不不不，你不是为我们写代码，你是为社区里的每个人写代码，你是为自己写代码。
为了提高你的技能，为了学习如何与他人合作。而对于那些做出重大贡献的人，
我们为您提供一个Apache Committer的席位，甚至是PPMC！</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="就这些了有任何问题请随时提出编码快乐">就这些了，有任何问题请随时提出。编码快乐！<a class="hash-link" href="#就这些了有任何问题请随时提出编码快乐" title="标题的直接链接">​</a></h3>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DevLake 加入 Apache 孵化器，来和我们一起玩开源！]]></title>
        <id>apache-welcomes-devlake</id>
        <link href="https://devlake.apache.org/zh/blog/apache-welcomes-devlake"/>
        <updated>2022-05-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[4 月 29 日，开源研发数据平台 DevLake 通过投票决议，正式成为 Apache 软件基金会 (ASF) 的孵化项目。]]></summary>
        <content type="html"><![CDATA[<p>4 月 29 日，开源研发数据平台 DevLake 通过投票决议，正式成为 Apache 软件基金会 (ASF) 的孵化项目。</p><p><img loading="lazy" alt="incubation" src="/zh/assets/images/incubation-screenshot-4dc642e1d68b6d7ec457d3e352c32053.jpg" width="1356" height="690" class="img_E7b_"></p><p>进入孵化器后，DevLake 将遵循 <a href="https://www.apache.org/theapacheway/index.html" target="_blank" rel="noopener noreferrer">The Apache Way</a>，在导师们的引导下，坚持以人为本、社区高于代码的理念，持续建设包容、多元、崇尚知识的社区。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake-主要特性">DevLake 主要特性<a class="hash-link" href="#devlake-主要特性" title="标题的直接链接">​</a></h3><p>作为开源的研发数据平台，DevLake 向软件研发团队提供自动化、一站式的数据收集、分析以及可视化能力，帮助研发团队借助数据更好地理解开发过程，挖掘关键瓶颈与提效机会。 </p><h4 class="anchor anchorWithStickyNavbar_mojV" id="归集-devops-全流程效能数据连接数据孤岛">归集 DevOps 全流程效能数据，连接数据孤岛<a class="hash-link" href="#归集-devops-全流程效能数据连接数据孤岛" title="标题的直接链接">​</a></h4><p>针对 DevOps 工具链复杂、数据收集难的痛点，DevLake 将需求-设计-开发-测试-交付-运营全流程、不同工具的效能数据汇集于一个平台，避免用户重复造轮子。</p><p>这些数据可以互相关联分析，进而更加准确、全面地刻画研发过程。举个例子，在了解项目 bug 修复的近况时，不仅可以了解已修复 bug 的个数，还可以了解这些 bug 的分布、bug 修复相关的代码工作量、所占总工作量比例等信息。</p><p>当前 DevLake 已支持主流项目管理工具 <a href="https://github.com/apache/incubator-devlake/tree/main/plugins/jira" target="_blank" rel="noopener noreferrer">JIRA cloud</a>、<a href="https://github.com/apache/incubator-devlake/tree/main/plugins/jira" target="_blank" rel="noopener noreferrer">JIRA server</a>、<a href="https://github.com/apache/incubator-devlake/tree/main/plugins/tapd" target="_blank" rel="noopener noreferrer">TAPD</a>，代码托管工具 <a href="https://github.com/apache/incubator-devlake/tree/main/plugins/gitextractor" target="_blank" rel="noopener noreferrer">Git</a>、<a href="https://github.com/apache/incubator-devlake/tree/main/plugins/github" target="_blank" rel="noopener noreferrer">GitHub</a>、<a href="https://github.com/apache/incubator-devlake/tree/main/plugins/gitlab" target="_blank" rel="noopener noreferrer">GitLab</a>，CI/CD 工具 <a href="https://github.com/apache/incubator-devlake/tree/main/plugins/jenkins" target="_blank" rel="noopener noreferrer">Jenkins</a>，日历工具<a href="https://github.com/apache/incubator-devlake/tree/main/plugins/feishu" target="_blank" rel="noopener noreferrer">飞书日历</a>。</p><p>数据源列表正在快速拓展中，您可以查看 Apache DevLake 已支持数据的<a href="https://devlake.apache.org/docs/DataModels/DataSupport" target="_blank" rel="noopener noreferrer">详细文档</a>，同时非常欢迎<a href="https://github.com/apache/incubator-devlake/blob/main/plugins/README.md" target="_blank" rel="noopener noreferrer">参与贡献新的数据源插件</a>！</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="标准化研发数据模型和开箱即用的效能指标">标准化研发数据模型和开箱即用的效能指标<a class="hash-link" href="#标准化研发数据模型和开箱即用的效能指标" title="标题的直接链接">​</a></h4><p>研发过程数据的标准化程度低，用户难以直接使用这些数据进一步分析；而效能指标定义与计算方法模糊，又给研发数据的应用带来了额外的成本。</p><p>Apache DevLake 提供了便捷的数据转化能力，将收集来的数据清洗转换为<a href="https://devlake.apache.org/docs/DataModels/DevLakeDomainLayerSchema" target="_blank" rel="noopener noreferrer">标准数据模型</a>，并基于标准模型生成一系列<a href="https://devlake.apache.org/docs/EngineeringMetrics" target="_blank" rel="noopener noreferrer">研发效能指标</a>，对用户来说简单易懂、开箱即用。一方面节省了治理数据和定义指标的成本，另一方面使效能指标更加透明，便于研发数据的应用落地。</p><p>目前 Apache DevLake 已支持 20+常见研发效能指标，可应用于交付效率、质量、成本、能力等不同认知域。</p><p>结合用户使用研发数据的具体场景，Apache DevLake 基于 Grafana 搭建数据看板，支持趋势分析、按照成员/阶段下钻等分析能力，帮助用户快速定位研发效能提升的关键环节。您可以查看<a href="https://devlake.apache.org/docs/LiveDemo" target="_blank" rel="noopener noreferrer">预设数据看板</a>，后续我们将在 blog 中介绍每一个数据看板及其背后的真实用户场景。</p><p><img loading="lazy" alt="面向开源产品的版本/模块质量分析" src="/zh/assets/images/Dashboard-1-0bd59aa8caf7e5684cc1359e0d82709a.jpg" width="1451" height="750" class="img_E7b_"></p><p><img loading="lazy" alt="面向开源产品的版本/模块质量分析" src="/zh/assets/images/Dashboard-2-d239627397b177b7108f0fc66b60dbbd.jpg" width="1447" height="896" class="img_E7b_"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="灵活的数据源插件系统及数据处理框架支持自定义">灵活的数据源插件系统及数据处理框架，支持自定义<a class="hash-link" href="#灵活的数据源插件系统及数据处理框架支持自定义" title="标题的直接链接">​</a></h4><p>Apache DevLake 将数据加工、关联与转换的底层能力开放出来，提供可拓展的数据底座。
用户可以根据实际需求，实现以下自定义：</p><ul><li>数据源自定义：Apache DevLake 基于 Golang plugin 系统设计了灵活的插件系统，支持用户独立开发接入任意 DevOps 工具</li><li>数据实体自定义：基于 dbt 插件，支持用户自定义数据转换模型</li><li>效能指标自定义：支持用户基于数据模型自定义指标，或调整指标计算方式</li><li>数据看板自定义：SQL 查询，在 Grafana 中拖拽搭建数据看板</li></ul><p>以下是 <a href="https://github.com/apache/incubator-devlake/blob/main/ARCHITECTURE.md" target="_blank" rel="noopener noreferrer">Apache DevLake 架构图</a>：</p><p><img loading="lazy" alt="面向开源产品的版本/模块质量分析" src="/zh/assets/images/0.11-architecture-diagram-f422e47efad0b84f72eb3bc51c7d1f1b.jpg" width="2143" height="1182" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="未来规划">未来规划<a class="hash-link" href="#未来规划" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="技术与产品方面">技术与产品方面<a class="hash-link" href="#技术与产品方面" title="标题的直接链接">​</a></h4><ul><li>集成更多数据源，覆盖整个软件开发生命周期 (SDLC)</li><li>提供更丰富的研发数据分析场景，与用户共建 Dashboard，实现更进一步的开箱即用</li><li>提升灵活性，用户能够根据自身业务需求，轻松地自定义数据模型和指标</li><li>优化用户体验，降低安装、配置、收集的成本，使用户专注数据分析</li><li>增强系统可伸缩性, 提升大规模数据场景下的系统性能</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="社区建设方面">社区建设方面<a class="hash-link" href="#社区建设方面" title="标题的直接链接">​</a></h4><ul><li>组织多种多样的社区活动，积极进行线上和线下技术布道，吸引更多用户、开发者和开源爱好者参与到 DevLake 的社区中来</li><li>打造开放、友好的交流环境，完善和丰富 DevLake 相关内容体系，完善用户文档和贡献指南，降低用户使用和参与门槛，向社区提供更及时的响应，积极与用户互动，解决用户问题并进一步促进项目迭代</li><li>积极与其他开源项目和社区展开合作，让更多生态合作伙伴了解和参与到 DevLake 社区，共建繁荣生态</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="为什么加入-asf-孵化器">为什么加入 ASF 孵化器<a class="hash-link" href="#为什么加入-asf-孵化器" title="标题的直接链接">​</a></h3><p>首先，DevLake 相信 The Apache way 是社区成功之道，以人为本开放、社区高于代码等理念将帮助 DevLake 健康、持续地成长。</p><p>其次，DevLake 和数据基建相关，与 Apache 基金会的关注点高度契合。DevLake 期待与 Apache 生态的其他大数据开源项目共同发展，共建生态。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="导师介绍">导师介绍<a class="hash-link" href="#导师介绍" title="标题的直接链接">​</a></h3><ul><li><a href="https://github.com/WillemJiang" target="_blank" rel="noopener noreferrer">姜宁</a>：DevLake Champion，ASF Member，同时也今年当选的 Apache 董事</li><li><a href="https://github.com/terrymanu" target="_blank" rel="noopener noreferrer">张亮</a>：SphereEx 公司创始人 &amp; CEO，ASF Member，Apache ShardingSphere 创始人 &amp; PMC Chair</li><li><a href="https://github.com/dailidong" target="_blank" rel="noopener noreferrer">代立冬</a>：白鲸开源联合创始人，ASF Member，Apache DolphinScheduler PMC Chair</li><li><a href="https://github.com/sijie" target="_blank" rel="noopener noreferrer">郭斯杰</a>：ASF Member, PMC Member on Apache Pulsar，StreamNative 创始人 &amp; CEO</li><li><a href="https://github.com/felixcheung" target="_blank" rel="noopener noreferrer">Felix Cheung</a>： ASF Member，Apache Zeppelin、Spark、SuperSet、YuniKorn、Pinot 等项目 PMC，SafeGraph 技术高级副总裁</li><li><a href="https://github.com/jbonofre" target="_blank" rel="noopener noreferrer">Jean-Baptiste Onofré</a>：ASF Member，Karaf PMC Chair，ActiveMQ、Archiva、Aries、Beam、Brooklyn、Camel、Carbondata、Felix 等项目 PMC</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="导师寄语">导师寄语<a class="hash-link" href="#导师寄语" title="标题的直接链接">​</a></h3><ul><li><p>姜宁：非常高兴能够成为 DevLake 的开源孵化领路人，帮助 DevLake 加入的 ASF 孵化器。 DevLake 着力于解决软件研发领域数据收集，以及研发瓶颈分析的痛点问题。欢迎对提升软件研发效率感兴趣的小伙伴参与到 DevLake 的使用和开发中来，一同构建繁荣发展的社区生态。 </p></li><li><p>张亮：欢迎 Apache 孵化器的新成员 DevLake。它将使工程效能领域的发展更加开放和繁荣，进而推动整个领域的标准化进程。欢迎更多的贡献者参与 ASF 社区，望 DevLake 早日毕业！</p></li><li><p>代立冬：很高兴看到 DevLake 加入到 Apache 孵化器，DevLake 是一个专为开发团队分析和提高工程生产力的平台，欢迎广大的开发伙伴们一起参与让 DevLake 社区更加繁荣、早日成为顶级项目！</p></li><li><p>郭斯杰：祝贺 DevLake 进入 Apache 软件基金会孵化器，这是 DevLake 走向世界的一大步，期待有更多技术爱好者和用户加入，共建繁荣。祝社区快速成长成为顶级项目，成为研发数据平台的中流砥柱。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="如何参与-devlake-社区">如何参与 DevLake 社区？<a class="hash-link" href="#如何参与-devlake-社区" title="标题的直接链接">​</a></h3><p>DevLake 的发展离不开社区用户的支持，欢迎所有人参与社区建设，让 DevLake 越来越有生命力🥳</p><ul><li>加入社群<ul><li>加入 <a href="https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-cHOjiYcBwERQ8VVPZ9cQQw" target="_blank" rel="noopener noreferrer">Slack</a> </li><li>点击下方代码仓库地址 &gt; Readme &gt; 扫描微信群二维码</li></ul></li><li>DevLake 代码仓库：<a href="https://github.com/apache/incubator-devlake/" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-devlake/</a></li><li>DevLake 官网：<a href="https://devlake.apache.org/" target="_blank" rel="noopener noreferrer">https://devlake.apache.org/</a></li><li>DevLake Podling Website：<a href="https://incubator.apache.org/projects/devlake.html" target="_blank" rel="noopener noreferrer">https://incubator.apache.org/projects/devlake.html</a></li><li>如何参与贡献：<a href="https://github.com/apache/incubator-devlake#how-to-contribute" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-devlake#how-to-contribute</a></li><li>订阅邮件列表了解动态：<a href="mailto:dev@devlake.incubator.apache.org" target="_blank" rel="noopener noreferrer">dev@devlake.incubator.apache.org</a></li></ul>]]></content>
        <author>
            <name>Weisi Deng</name>
            <uri>https://github.com/Ushuaiaff</uri>
        </author>
        <category label="devlake" term="devlake"/>
        <category label="apache" term="apache"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apache DevLake是怎么跑起来的]]></title>
        <id>how-apache-devlake-runs</id>
        <link href="https://devlake.apache.org/zh/blog/how-apache-devlake-runs"/>
        <updated>2022-05-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Apache DevLake 是一个DevOps数据收集和整合工具，通过 Grafana 为开发团队呈现出不同阶段的数据，让团队能够以数据为驱动改进开发流程。]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">Apache DevLake</a> 是一个DevOps数据收集和整合工具，通过 Grafana 为开发团队呈现出不同阶段的数据，让团队能够以数据为驱动改进开发流程。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="apache-devlake-架构概述">Apache DevLake 架构概述<a class="hash-link" href="#apache-devlake-架构概述" title="标题的直接链接">​</a></h3><ul><li>左边是<a href="https://devlake.apache.org/docs/DataModels/DataSupport" target="_blank" rel="noopener noreferrer">可集成的DevOps数据插件</a>，目前已有的插件包括 Github，Gitlab，JIRA，Jenkins，Tapd，Feishu 以及思码逸主打的代码分析引擎</li><li>中间是主体框架，通过主体框架运行插件中的子任务，完成数据的收集，扩展，并转换到领域层，用户可以通过 config-ui 或者 api 调用的形式来触发任务</li><li>RMDBS 目前支持 Mysql 和 PostgreSQL，后期还会继续支持更多的数据库</li><li>Grafana 可以通过sql语句生成团队需要的各种数据</li></ul><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.001-9fe996eee294ce1843bc3f126a1a7b89.png" width="567" height="310" class="img_E7b_"></p><blockquote><p>接下来我们就详细聊一聊系统是怎么跑起来的。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_mojV" id="系统启动">系统启动<a class="hash-link" href="#系统启动" title="标题的直接链接">​</a></h3><p>在我们的 golang 程序启动之前，首先会自动调用各个 package 的 init() 方法，我们主要看看services 包的载入，下面的代码有详细注释：</p><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">func</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">init</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> err </span><span class="token builtin">error</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 获取配置信息</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> config</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">GetConfig</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 获取到数据库</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> runner</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">NewGormDb</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> logger</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Global</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Nested</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"db"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 配置时区</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">location </span><span class="token operator" style="color:#393A34">:=</span><span class="token plain"> cron</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">WithLocation</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">time</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">UTC</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 创建定时任务管理器</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cronManager </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> cron</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">New</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">location</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 初始化数据迁移</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">migration</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Init</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 注册框架的数据迁移脚本</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">migrationscripts</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">RegisterAll</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 载入插件，从cfg.GetString("PLUGIN_DIR")获取到的文件夹中载入所有.so文件，在LoadPlugins方法中，具体来讲，通过调用runner.LoadPlugins将pluginName:PluginMeta键值对存入到core.plugins中</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> runner</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">LoadPlugins</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">GetString</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"PLUGIN_DIR"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cfg</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">logger</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Global</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Nested</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">"plugin"</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 执行数据迁移脚本，完成数据库框架层各个表的初始化</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">err </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> migration</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Execute</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">context</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">Background</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> err </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">panic</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">err</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// call service init</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">pipelineServiceInit</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake的任务执行原理">DevLake的任务执行原理<a class="hash-link" href="#devlake的任务执行原理" title="标题的直接链接">​</a></h3><p><strong>Pipeline的运行流程</strong></p><p>在讲解Pipeline流程之前，我们需要先解释一下<a href="https://devlake.apache.org/docs/Glossary#blueprints" target="_blank" rel="noopener noreferrer">Blueprint</a>。</p><p>Blueprint是一个定时任务，包含了需要执行的子任务以及执行计划。Blueprint 的每一次执行记录是一条Historical Run（也称为 Pipeline），代表 DevLake 一次触发，通过一个或多个插件，完成了一个或多个数据收集转换的任务。</p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.002-40065677c2b00df89eeaac1d9512f286.png" width="567" height="263" class="img_E7b_"></p><p>以下是 Pipeline 运行流程图：</p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.003-d07631a740cb5b056d15a35627afef80.png" width="344" height="515" class="img_E7b_"></p><p>一个pipeline包含一个二维数组tasks，主要是为了保证一系列任务按预设顺序执行。如果下图中的 Stage3 的插件需要依赖其他插件准备数据（例如 refdiff 的运行需要依赖 gitextractor 和 github，数据源与插件的更多信息请看<a href="https://devlake.apache.org/docs/DataModels/DataSupport" target="_blank" rel="noopener noreferrer">文档</a>），那么 Stage 3 开始执行时，需要保证其依赖项已在 Stage1 和 Stage2 执行完成：</p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.004-a6a550c4f00b232abc7b28e30738be09.png" width="567" height="238" class="img_E7b_"></p><p><strong>Task的运行流程</strong></p><p>在stage1，stage2，stage3中的各插件任务都是并行执行：</p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.005-4d14031484d1272b4be8d7ff2f08d2a2.png" width="304" height="501" class="img_E7b_"></p><p><strong>接下来就是顺序执行插件中的子任务</strong></p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.006-83ed245c2c8d805aca908814f0f0f5f9.png" width="331" height="617" class="img_E7b_"></p><ol><li>RunTask 之前的工作都是在准备 RunTask 方法需要的参数，比如 logger，db，context 等等。</li><li>RunTask 方法中主要是对数据库中的tasks进行状态更新，同时，准备运行插件任务的 options（把从 config-ui 传过来的 json 转成 map 传到 RunPluginTask 中）</li><li>RunPluginTask 首先通过 core.GetPlugin(pluginName) 获取到对应 <a href="#pm">PluginMeta</a>，然后通过 PluginMeta 获取到 <a href="#pt">PluginTask</a>，再执行 RunPluginSubTasks</li></ol><p><strong>每一个插件子任务的运行流程（涉及到的 interface 及 func 会在<a href="#DevLake%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%8E%A5%E5%8F%A3">下一节</a>详细阐述）</strong></p><p><img loading="lazy" alt="Generated" src="/zh/assets/images/Aspose.Words.093a76ac-457b-4498-a472-7dbea580bca9.007-09a5f7c401dfb5a557b10c3870d103fe.png" width="567" height="214" class="img_E7b_"></p><ol><li>通过调用SubTaskMetas()获取到所有插件所有的可用子任务<a href="#stm">subtaskMeta</a></li><li>通过<code>options["tasks"]</code>以及subtaskMeta组建需要执行的子任务集合subtaskMetas</li><li>计算总共多少个子任务</li><li>通过<code>helper.NewDefaultTaskContext</code>构建<a href="#tc">taskCtx</a></li><li>调用<code>pluginTask.PrepareTaskData</code>构建<a href="#td">taskData</a>，</li><li>接下来迭代subtaskMetas里面的所有子任务<ol><li>通过<code>taskCtx.SubTaskContext(subtaskMeta.Name)</code>获取到子任务的<a href="#sc">subtaskCtx</a></li><li>执行<a href="#step"><code>subtaskMeta.EntryPoint(subtaskCtx)</code></a></li></ol></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake中的重要接口">DevLake中的重要接口<a class="hash-link" href="#devlake中的重要接口" title="标题的直接链接">​</a></h3><ol><li><a id="pm">PluginMeta</a>: 包含了插件最基本的两个方法，所有插件都需要实现，系统启动的时候存在core.plugins中，在执行插件任务的时候通过core.GetPlugin获取</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> PluginMeta </span><span class="token keyword" style="color:#00009f">interface</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">Description</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token builtin">string</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">//PkgPath information will be lost when compiled as plugin(.so), this func will return that info</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">RootPkgPath</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token builtin">string</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="2"><li><a id="pt">PluginTask</a>: 通过PluginMeta获取，插件实现这个方法之后，Framework就能直接运行子任务，而不是扔给插件自己去执行，最大的好处就是插件的子任务实现更加简单，在插件运行当中，我们也可以更容易的去干涉（比如增加日志等等）</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">type</span><span class="token plain"> PluginTask </span><span class="token keyword" style="color:#00009f">interface</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// return all available subtasks, framework will run them for you in order</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">SubTaskMetas</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">SubTaskMeta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// based on task context and user input options, return data that shared among all subtasks</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token function" style="color:#d73a49">PrepareTaskData</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">taskCtx TaskContext</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> options </span><span class="token keyword" style="color:#00009f">map</span><span class="token punctuation" style="color:#393A34">[</span><span class="token builtin">string</span><span class="token punctuation" style="color:#393A34">]</span><span class="token keyword" style="color:#00009f">interface</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">interface</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token builtin">error</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="3"><li>每个插件还有一个<a id="td">taskData</a>，里面包含了配置选项，apiClient以及一些插件其它属性（比如github有Repo信息）</li><li><a id="stm">SubTaskMeta</a>: 一个子任务的元数据，每个子任务都会定义一个SubTaskMeta</li></ol><div class="codeBlockContainer_I0IT language-go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> CollectMeetingTopUserItemMeta </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> core</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">SubTaskMeta</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"collectMeetingTopUserItem"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   EntryPoint</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> CollectMeetingTopUserItem</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   EnabledByDefault</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Description</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"Collect top user meeting data from Feishu api"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><ol start="5"><li><a id="ec">ExecContext</a>: 定义了执行(子)任务需要的所有资源</li><li><a id="stc">SubTaskContext</a>: 定义了执行子任务所需要的资源（包含了ExecContext）</li><li><a id="tc">TaskContext</a>: 定义了执行插件任务所需要的资源（包含了ExecContext）。与SubTaskContext的区别在于SubTaskContext中的TaskContext()方法可以返回TaskContext，而TaskContext中的方法SubTaskContext(subtask string)方法可以返回SubTaskContext，子任务隶属于插件任务，所以把这两个Context进行了区分</li><li><a id="step">SubTaskEntryPoint</a>: 所有的插件子任务都需要实现这个函数，这样才能由框架层统一协调安排</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="后续">后续<a class="hash-link" href="#后续" title="标题的直接链接">​</a></h3><p>这篇文章介绍了 DevLake 的架构以及运行流程，还有三个核心 api<!-- -->_<!-- -->collector、api<!-- -->_<!-- -->extractor 和 data<!-- -->_<!-- -->convertor 将会在下一篇文章进行剖析。</p>]]></content>
        <author>
            <name>陈映初</name>
            <uri>https://github.com/warren830</uri>
        </author>
        <category label="devlake" term="devlake"/>
        <category label="apache" term="apache"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用ants引发的死锁]]></title>
        <id>deadlock-caused-by-using-ants</id>
        <link href="https://devlake.apache.org/zh/blog/deadlock-caused-by-using-ants"/>
        <updated>2022-04-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[1. 背景]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_mojV" id="1-背景">1. 背景<a class="hash-link" href="#1-背景" title="标题的直接链接">​</a></h3><p>我们的项目有大量的api请求由goroutine完成，所以我们需要引入一个pool来节省频繁创建goroutine所造成的的开销，同时也可以更简易的调度goroutine，在对github上多个协程池的对比后，我们最终选定了<a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener noreferrer">ants</a>作为我们的调度管理pool。</p><ol><li>最近在测试中偶然发现系统出现了“死锁”的情况，进而采取断网的方式发现“死锁”在极端情况下是稳定出现，经过满篇的log，break，最终把问题定位到了ants的submit方法。这个问题来自于在使用ants pool的过程中，为了实现重试，我们在方法中又递归调用了方法本身，也就是submit task内部又submit一个task，下面是简化后的代码：</li></ol><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">func (apiClient *ApiAsyncClient) DoAsync(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   retry int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return apiClient.scheduler.Submit(func() error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      _, err := apiClient.Do()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if err != nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         if retry &lt; apiClient.maxRetry {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return apiClient.DoAsync(retry+1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return err</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在上面的代码块中，可以看到return apiClient.DoAsync(retry+1)这一步递归调用了自己，即在submit中又调用了submit</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-深入ants分析">2. 深入ants分析<a class="hash-link" href="#2-深入ants分析" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="img" src="/zh/assets/images/ants_source_code_1-dbc90cd562952b6434590b8ae7121255.png" width="333" height="231" class="img_E7b_"></p><ul><li>在上面submit源码中可以看到，首先是通过retrieveWorker回去一个worker，然后把task放入到worker的task channel当中，很简单，也看不出来为什么会“dead lock”，没办法，去到retrieveWorker</li></ul><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// retrieveWorker returns a available worker to run the tasks.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">func (p *Pool) retrieveWorker() (w *goWorker) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> spawnWorker := func() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w = p.workerCache.Get().(*goWorker)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w.run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> p.lock.Lock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> w = p.workers.detach()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if w != nil { // first try to fetch the worker from the queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else if capacity := p.Cap(); capacity == -1 || capacity &gt; p.Running() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // if the worker queue is empty and we don't run out of the pool capacity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // then just spawn a new worker goroutine.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else { // otherwise, we'll have to keep them blocked and wait for at least one worker to be put back into pool.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.Nonblocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.MaxBlockingTasks != 0 &amp;&amp; p.blockingNum &gt;= p.options.MaxBlockingTasks {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.cond.Wait() // block and wait for an available worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var nw int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if nw = p.Running(); nw == 0 { // awakened by the scavenger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if !p.IsClosed() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if w = p.workers.detach(); w == nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if nw &lt; capacity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   goto retry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><img loading="lazy" alt="img" src="/zh/assets/images/ants_source_code_flowchart-6f51973ac906b9029502a2c9063df6ad.png" width="1280" height="481" class="img_E7b_"></p><ul><li>这个方法的大概流程就是先对pool上锁，然后从pool的worker队列中去取一个worker，detach其实就是返回了worker，并且把这个worker从队列中删除掉了，接下来有三种情况<ul><li>如果成功取到worker，解锁p，返回取到的worker</li><li>如果worker队列是空的并且pool的容量没有耗尽，就解锁pool并生成一个新的worker返回给submit</li><li>最后一种情况就是pool容量耗尽了，worker队列也没有空闲的worker，那就要根据我们创建pool时传入的参数来决定下一步情况了<ul><li>首先说一下这里涉及的两个重要参数，一个是capacity，这个值如果在new pool的时候不设置，会是MaxInt32，相当于无限制的goroutine，但是情况不同的是，我们会首先复用空闲的worker，还可以定时清空多余的空闲worker，blockingNum为正在等待的goroutine，初始为0</li><li>如果设置了Nonblocking为true，直接解锁，返回nil，submit就会直接返回一个错误ErrPoolOverload，代表pool超负荷了，不做任何其他处理，submit失败，结束~~</li><li>另一种情况就是没有设置Nonblocking，默认为false，就进入到了一个retry标签，这里面就涉及到了另一个创建pool时候的参数MaxBlockingTasks，这个MaxBlockingTasks就是一个threshold<ul><li>首先判断如果设置了MaxBlockingTasks并且当前blockingNum大于或者等于MaxBlockingTasks，那么直接解锁pool并且返回nil，submit失败，结束~~</li><li>上面的条件不满足，则首先blockingNum++，然后开始wait一直到有worker摸完鱼回来工作，则blockingNum--。问题就在这里了！！！如果所有的worker都在工作（也许是看起来在工作，实际上在摸鱼），这里就会一直wait()，也就是我们自己代码中return后面的DoAsync会一直wait()，从我们自己的项目来讲，就是所有worker这个时候都在submit一个新的task到同一个pool中，而这个时候pool已经满了，导致所有worker都阻塞在了这里，“死锁”也就出现了</li></ul></li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-最后聊几句自己对于golang内存模型的理解">3. 最后聊几句自己对于golang内存模型的理解<a class="hash-link" href="#3-最后聊几句自己对于golang内存模型的理解" title="标题的直接链接">​</a></h3><ol><li>go的调度流程本质上是一个生产-消费的过程，我们利用go func是生产了一个task放到队列中，由系统线程从队列中获取协程然后执行</li><li>讲到go的调度流程，咱们就不能不说一下go的MPG（分别解释一下，就不做深入了，如果有人看，后期再努力整理一份详细聊聊）<ol><li>M 代表着一个内核线程，也可以称为一个工作线程，所有的goroutine都是跑在M之上的</li><li>P可以理解为一个逻辑处理器，主要由P来执行goroutine</li><li>G就是go func封装的这个方法</li></ol></li><li>真正的并发数是由GOMAXPROCS来决定的，并不是提交多少goroutine，并发数就是多少，GOMAXPROCS是由机器的cpu核数来决定的</li><li>所以回到第2部分，pool.cond.wait等待的是绑定上一个goroutine，和其他语言的等待线程具有相似却完全不同的意义，每一个worker是一个G，pool也就是一个队列，而M会从队列中获取可以执行的G，当所有的G都在等待创建新的G时，M全部都处于空闲状态</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="4-解决方案">4. 解决方案<a class="hash-link" href="#4-解决方案" title="标题的直接链接">​</a></h3><ol><li>当然，最靠谱的应该是尽量避免类似这样的递归调用操作</li><li>如果实在不行，可以考虑添加一个sub pool，作为次级队列，让递归生成的G可以在sub pool里等待空闲的M来处理</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="5-对比不同size的pool和两个pool的内存alloc_space和cpu开销">5. 对比不同size的pool和两个pool的内存（alloc_space）和CPU开销<a class="hash-link" href="#5-对比不同size的pool和两个pool的内存alloc_space和cpu开销" title="标题的直接链接">​</a></h3><table><thead><tr><th>Pool size</th><th>CPU(ants)%</th><th>CPU(runtime.gcBgMarkWorker)%</th><th>CPU(runtime.mcall)%</th><th>内存(runtime.allocm)kB</th><th>内存(runtime.gcBgMarkWorker)kB</th><th>内存(root)</th></tr></thead><tbody><tr><td>Two pools(158, 632)</td><td>27.98</td><td>7.73</td><td>25.44</td><td>2050.25</td><td>512.02</td><td>8798</td></tr><tr><td>Pool 158</td><td>28.11</td><td>6.61</td><td>25.08</td><td>2050</td><td></td><td>6661</td></tr><tr><td>Pool 1580</td><td>27.41</td><td>12.96</td><td>23.17</td><td>3075.38</td><td></td><td>10264</td></tr><tr><td>Pool 7900</td><td>25.89</td><td>9.82</td><td>22.52</td><td>3587.94</td><td></td><td>5725</td></tr><tr><td>Pool 790000</td><td>25.12</td><td>12.79</td><td>23.44</td><td>3075.38</td><td></td><td>9748</td></tr></tbody></table><p>runtime.gcBgMarkWorker: 用于标记垃圾对象</p><p>从上面的表格可以看到，可能存在多核的影响，所以对于我们公司现在需要的并发数量级来讲，pool的size对系统影响并不大。</p>]]></content>
        <author>
            <name>陈映初</name>
            <uri>https://github.com/warren830</uri>
        </author>
        <category label="devlake" term="devlake"/>
        <category label="ants" term="ants"/>
    </entry>
</feed>