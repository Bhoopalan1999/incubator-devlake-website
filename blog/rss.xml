<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Apache DevLake (Incubating) Blog</title>
        <link>https://devlake.apache.org/blog</link>
        <description>Apache DevLake (Incubating) Blog</description>
        <lastBuildDate>Wed, 18 May 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Apache Incubator Welcomes DevLake, A Dev-Data Platform Serving Developers]]></title>
            <link>https://devlake.apache.org/blog/apache-welcomes-devlake</link>
            <guid>apache-welcomes-devlake</guid>
            <pubDate>Wed, 18 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[We are excited to share today that the Apache Software Foundation (ASF) voted to make DevLake an officially supported project of the Apache Incubator.]]></description>
            <content:encoded><![CDATA[<p>We are excited to share today that the Apache Software Foundation (ASF) voted to make DevLake an officially supported project of the Apache Incubator.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="what-is-devlake">What is DevLake?<a class="hash-link" href="#what-is-devlake" title="Direct link to heading">​</a></h3><p>Launched in December of 2021, <a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">DevLake</a> is an open-source dev data platform that ingests, analyzes, and visualizes the fragmented data in developer tools. </p><p>Software development is complex, requiring many tools and processes, and as a result creates a storm of data scattered across tools in many formats. This makes it difficult to organize, query, and make sense of.  We built DevLake, to make it easy to make sense of this rich data and to translate it into actionable insights.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlakes-key-features">DevLake's key features:<a class="hash-link" href="#devlakes-key-features" title="Direct link to heading">​</a></h3><ul><li>Collect DevOps data across software development lifecycle (SDLC) to connect data islands.</li><li>Standardized data models with out-of-the-box metrics and customizable dashboards.</li><li>Flexible plugin system for user-defined data integration and transformation.</li></ul><p>Below is the architecture of DevLake:
<img loading="lazy" alt="architecture" src="/assets/images/0.11-architecture-diagram-f422e47efad0b84f72eb3bc51c7d1f1b.jpg" width="2143" height="1182" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="why-join-apache-incubator">Why join Apache Incubator?<a class="hash-link" href="#why-join-apache-incubator" title="Direct link to heading">​</a></h3><p>First and foremost, we firmly believe in Apache's principle of "Community over Code" and <a href="https://www.apache.org/theapacheway/index.html" target="_blank" rel="noopener noreferrer">"The Apache Way"</a>. We look forward to building a vibrant, inclusive, and diverse community under the guidance of our mentors through the incubator journey.</p><p>We also feel that the Apache community has one of the strongest ecosystems when it comes to data-oriented open-source projects. </p><p>Last and not least, the support and enthusiasm of the Apache community and mentors made it clear to us that this would be a place where we can truly evolve and nurture DevLake.</p><p>In the months leading up to DevLake's acceptance, our mentors provided guidance and suggestions instrumental to making this important moment a reality. We want to take this opportunity to thank and acknowledge them: </p><ul><li><p><strong><a href="https://github.com/WillemJiang" target="_blank" rel="noopener noreferrer">Willem Ning Jiang</a></strong>: DevLake Champion; ASF Member &amp; Board Director</p></li><li><p><strong><a href="https://github.com/terrymanu" target="_blank" rel="noopener noreferrer">Liang Zhang</a></strong>: Founder &amp; CEO of SphereEx; ASF Member, Founder &amp; PMC Chair of Apache ShardingSphere</p></li><li><p><strong><a href="https://github.com/dailidong" target="_blank" rel="noopener noreferrer">Lidong Dai</a></strong>: ASF Member; Apache DolphinScheduler PMC Chair</p></li><li><p><strong><a href="https://github.com/sijie" target="_blank" rel="noopener noreferrer">Sijie Guo</a></strong>: ASF Member, PMC member of Apache Pulsar; Founder &amp; CEO of StreamNative</p></li><li><p><strong><a href="https://github.com/felixcheung" target="_blank" rel="noopener noreferrer">Felix Cheung</a></strong>: ASF Member, PMC on Spark, Superset, Yunikorn, Zeppelin, Pinot, and Incubator. SVP of Engineering at SafeGraph.</p></li><li><p><strong><a href="https://github.com/jbonofre" target="_blank" rel="noopener noreferrer">Jean-Baptiste Onofré</a></strong>: ASF Member, Karaf PMC Chair, PMC on ActiveMQ, Archiva, Aries, Beam, Brooklyn, Camel, Carbondata, Felix, Incubator, and <a href="http://people.apache.org/committer-index.html" target="_blank" rel="noopener noreferrer">many more</a>.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="devlake-future-roadmap">DevLake Future Roadmap<a class="hash-link" href="#devlake-future-roadmap" title="Direct link to heading">​</a></h3><ul><li>Enhance system scalability and performance in large-scale data scenarios.</li><li>Integrate more data sources and tools (JIRA, GitHub, GitLab, and Jenkins are already supported.)</li><li>Enable support for OLAP databases, providing users with more choices.</li><li>Provide more scenario-specific, out-of-the-box dashboards and templates reflecting best practices and well-known methodologies to improve usability.</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="join-us">Join us!<a class="hash-link" href="#join-us" title="Direct link to heading">​</a></h3><p>We invite developers and those passionate about data-driven engineering to 'dive into the lake' with us, and welcome contributions of all kinds.
Join us on Slack and at our weekly open source community meetups🥳</p><p><strong>Apache DevLake (Incubating) Links:</strong></p><ul><li>GitHub:  <a href="https://github.com/apache/incubator-devlake" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-devlake</a></li><li>DevLake Official Website: <a href="https://devlake.apache.org/" target="_blank" rel="noopener noreferrer">https://devlake.apache.org/</a></li><li>Slack:  <a href="https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-_P30EyJIxavGtZ3vTHWLJA" target="_blank" rel="noopener noreferrer">https://join.slack.com/t/devlake-io/shared_invite/zt-18uayb6ut-_P30EyJIxavGtZ3vTHWLJA</a></li><li>DevLake Podling Website：<a href="https://incubator.apache.org/projects/devlake.html" target="_blank" rel="noopener noreferrer">https://incubator.apache.org/projects/devlake.html</a></li></ul>]]></content:encoded>
            <category>Devlake</category>
            <category>Apache</category>
        </item>
        <item>
            <title><![CDATA[使用ants引发的死锁]]></title>
            <link>https://devlake.apache.org/blog/deadlock-caused-by-using-ants</link>
            <guid>deadlock-caused-by-using-ants</guid>
            <pubDate>Sat, 30 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[1. 背景]]></description>
            <content:encoded><![CDATA[<h3 class="anchor anchorWithStickyNavbar_mojV" id="1-背景">1. 背景<a class="hash-link" href="#1-背景" title="Direct link to heading">​</a></h3><p>我们的项目有大量的api请求由goroutine完成，所以我们需要引入一个pool来节省频繁创建goroutine所造成的的开销，同时也可以更简易的调度goroutine，在对github上多个协程池的对比后，我们最终选定了<a href="https://github.com/panjf2000/ants" target="_blank" rel="noopener noreferrer">ants</a>作为我们的调度管理pool。</p><ol><li>最近在测试中偶然发现系统出现了“死锁”的情况，进而采取断网的方式发现“死锁”在极端情况下是稳定出现，经过满篇的log，break，最终把问题定位到了ants的submit方法。这个问题来自于在使用ants pool的过程中，为了实现重试，我们在方法中又递归调用了方法本身，也就是submit task内部又submit一个task，下面是简化后的代码</li></ol><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">func (apiClient *ApiAsyncClient) DoAsync(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   retry int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return apiClient.scheduler.Submit(func() error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      _, err := apiClient.Do()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if err != nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         if retry &lt; apiClient.maxRetry {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return apiClient.DoAsync(retry+1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return err</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>在上面的代码块中，可以看到return apiClient.DoAsync(retry+1)这一步递归调用了自己，即在submit中又调用了submit</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-深入ants分析">2. 深入ants分析<a class="hash-link" href="#2-深入ants分析" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="img" src="/assets/images/ants_source_code_1-dbc90cd562952b6434590b8ae7121255.png" width="333" height="231" class="img_E7b_"></p><ul><li>在上面submit源码中可以看到，首先是通过retrieveWorker回去一个worker，然后把task放入到worker的task channel当中，很简单，也看不出来为什么会“dead lock”，没办法，去到retrieveWorker</li></ul><div class="codeBlockContainer_I0IT language-Go theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-Go codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// retrieveWorker returns a available worker to run the tasks.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">func (p *Pool) retrieveWorker() (w *goWorker) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> spawnWorker := func() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w = p.workerCache.Get().(*goWorker)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  w.run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> p.lock.Lock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> w = p.workers.detach()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> if w != nil { // first try to fetch the worker from the queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else if capacity := p.Cap(); capacity == -1 || capacity &gt; p.Running() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // if the worker queue is empty and we don't run out of the pool capacity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // then just spawn a new worker goroutine.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> } else { // otherwise, we'll have to keep them blocked and wait for at least one worker to be put back into pool.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.Nonblocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> retry:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if p.options.MaxBlockingTasks != 0 &amp;&amp; p.blockingNum &gt;= p.options.MaxBlockingTasks {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.cond.Wait() // block and wait for an available worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.blockingNum--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var nw int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if nw = p.Running(); nw == 0 { // awakened by the scavenger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if !p.IsClosed() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if w = p.workers.detach(); w == nil {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if nw &lt; capacity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spawnWorker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   goto retry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  p.lock.Unlock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p><img loading="lazy" alt="img" src="/assets/images/ants_source_code_flowchart-6f51973ac906b9029502a2c9063df6ad.png" width="1280" height="481" class="img_E7b_"></p><ul><li>这个方法的大概流程就是先对pool上锁，然后从pool的worker队列中去取一个worker，detach其实就是返回了worker，并且把这个worker从队列中删除掉了，接下来有三种情况<ul><li>如果成功取到worker，解锁p，返回取到的worker</li><li>如果worker队列是空的并且pool的容量没有耗尽，就解锁pool并生成一个新的worker返回给submit</li><li>最后一种情况就是pool容量耗尽了，worker队列也没有空闲的worker，那就要根据我们创建pool时传入的参数来决定下一步情况了<ul><li>首先说一下这里涉及的两个重要参数，一个是capacity，这个值如果在new pool的时候不设置，会是MaxInt32，相当于无限制的goroutine，但是情况不同的是，我们会首先复用空闲的worker，还可以定时清空多余的空闲worker，blockingNum为正在等待的goroutine，初始为0</li><li>如果设置了Nonblocking为true，直接解锁，返回nil，submit就会直接返回一个错误ErrPoolOverload，代表pool超负荷了，不做任何其他处理，submit失败，结束~~</li><li>另一种情况就是没有设置Nonblocking，默认为false，就进入到了一个retry标签，这里面就涉及到了另一个创建pool时候的参数MaxBlockingTasks，这个MaxBlockingTasks就是一个threshold<ul><li>首先判断如果设置了MaxBlockingTasks并且当前blockingNum大于或者等于MaxBlockingTasks，那么直接解锁pool并且返回nil，submit失败，结束~~</li><li>上面的条件不满足，则首先blockingNum++，然后开始wait一直到有worker摸完鱼回来工作，则blockingNum--。问题就在这里了！！！如果所有的worker都在工作（也许是看起来在工作，实际上在摸鱼），这里就会一直wait()，也就是我们自己代码中return后面的DoAsync会一直wait()，从我们自己的项目来讲，就是所有worker这个时候都在submit一个新的task到同一个pool中，而这个时候pool已经满了，导致所有worker都阻塞在了这里，“死锁”也就出现了</li></ul></li></ul></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-最后聊几句自己对于golang内存模型的理解">3. 最后聊几句自己对于golang内存模型的理解<a class="hash-link" href="#3-最后聊几句自己对于golang内存模型的理解" title="Direct link to heading">​</a></h3><ol><li>go的调度流程本质上是一个生产-消费的过程，我们利用go func是生产了一个task放到队列中，由系统线程从队列中获取协程然后执行</li><li>讲到go的调度流程，咱们就不能不说一下go的MPG（分别解释一下，就不做深入了，如果有人看，后期再努力整理一份详细聊聊）<ol><li>M 代表着一个内核线程，也可以称为一个工作线程，所有的goroutine都是跑在M之上的</li><li>P可以理解为一个逻辑处理器，主要由P来执行goroutine</li><li>G就是go func封装的这个方法</li></ol></li><li>真正的并发数是由GOMAXPROCS来决定的，并不是提交多少goroutine，并发数就是多少，GOMAXPROCS是由机器的cpu核数来决定的</li><li>所以回到第2部分，pool.cond.wait等待的是绑定上一个goroutine，和其他语言的等待线程具有相似却完全不同的意义，每一个worker是一个G，pool也就是一个队列，而M会从队列中获取可以执行的G，当所有的G都在等待创建新的G时，M全部都处于空闲状态</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="4-解决方案">4. 解决方案<a class="hash-link" href="#4-解决方案" title="Direct link to heading">​</a></h3><ol><li>当然，最靠谱的应该是尽量避免类似这样的递归调用操作</li><li>如果实在不行，可以考虑添加一个sub pool，作为次级队列，让递归生成的G可以在sub pool里等待空闲的M来处理</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="5-对比不同size的pool和两个pool的内存alloc_space和cpu开销">5. 对比不同size的pool和两个pool的内存（alloc_space）和CPU开销<a class="hash-link" href="#5-对比不同size的pool和两个pool的内存alloc_space和cpu开销" title="Direct link to heading">​</a></h3><table><thead><tr><th>Pool size</th><th>CPU(ants)%</th><th>CPU(runtime.gcBgMarkWorker)%</th><th>CPU(runtime.mcall)%</th><th>内存(runtime.allocm)kB</th><th>内存(runtime.gcBgMarkWorker)kB</th><th>内存(root)</th></tr></thead><tbody><tr><td>Two pools(158, 632)</td><td>27.98</td><td>7.73</td><td>25.44</td><td>2050.25</td><td>512.02</td><td>8798</td></tr><tr><td>Pool 158</td><td>28.11</td><td>6.61</td><td>25.08</td><td>2050</td><td></td><td>6661</td></tr><tr><td>Pool 1580</td><td>27.41</td><td>12.96</td><td>23.17</td><td>3075.38</td><td></td><td>10264</td></tr><tr><td>Pool 7900</td><td>25.89</td><td>9.82</td><td>22.52</td><td>3587.94</td><td></td><td>5725</td></tr><tr><td>Pool 790000</td><td>25.12</td><td>12.79</td><td>23.44</td><td>3075.38</td><td></td><td>9748</td></tr></tbody></table><p>runtime.gcBgMarkWorker: 用于标记垃圾对象</p><p>从上面的表格可以看到，可能存在多核的影响，所以对于我们公司现在需要的并发数量级来讲，pool的size对系统影响并不大。</p>]]></content:encoded>
            <category>devlake</category>
            <category>ants</category>
        </item>
    </channel>
</rss>